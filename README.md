Usage examples
--------------

= Расширенный алгоритм Евклида =

Алгоритм Евклида можно расширить так, что он не только даст НОД(a,b)=d, но и найдет целые числа x и y, такие что ax + by = d.

Псевдокод.
```
НА ВХОДЕ: два неотрицательных числа a и b: a>=b
НА ВЫХОДЕ: d=НОД(a,b) и целые x,y: ax + by = d.

1. Если b=0 положить d:=a, x:=1, y:=0 и возвратить (d,x,y)
2. Положить x2:=1, x1:=0, y2:=0, y1:=1
3. Пока b>0
    3.1 q:=[a/b], r:=a-qb, x:=x2-qx1, y:=y2-qy1
    3.2 a:=b, b:=r, x2:=x1, x1:=x, y2:=y1, y1:=y
4. Положить d:=a, x:=x2, y:=y2 и возвратить (d,x,y)
```
Алгоритм работает за O(log2n) операций.

= Нахождение обратного элемента по модулю =

Для начала заметим, что элемент a кольца Zn обратим тогда и только тогда, когда НОД(a,n)=1. То есть ответ есть не всегда. Из определения обратного элемента прямо следует алгоритм.

Псевдокод.
```
НА ВХОДЕ: а из Zn.
НА ВЫХОДЕ: обратный к а в кольце, если он существует.

1. Использовать расширенный алгоритм Евклида для нахождения
   x и y, таких что ax + ny = d, где d=НОД(a,n).
2. Если d > 1, то обратного элемента не существует.
    Иначе возвращаем x.
```

= НОК =

НОК(a , b) = a*b / НОД(a, b)

= Алгоритм Евклида =

Псевдо.
```
1. Вычислим r - остаток от деления числа a на b, a = bq+r, 0 <= r < b.

2. Если r = 0, то b есть искомое число.

3. Если r =/= 0, то заменим пару чисел (a,b) парой (b,r)
и перейдем к шагу 1.
```

C++
```
int NOD(int a,int b)
 {
    while(a!=0 && b!=0)
    {
       if(a>=b) a=a%b;
           else b=b%a;
    }
 return a+b; // Одно - ноль
 }
``` 

При вычислении наибольшего общего делителя (a,b) с помощью алгоритма Евклида будет выполнено не более 5p операций деления с остатком, где p есть количество цифр в десятичной записи меньшего из чисел a и b. 

```
Реализацию тяжко. А вот пояснить, что делать могу.
b - обратный к a по mod m, если a*b = 1 mod m
(a,m) - НОД чисел

При помощи алгоритма Эвклида можно найти НОД этих чисел.

Если (a,m)=d>1 (числа не взаимно простые), то a не имеет обратной величины по модулю m.

Если (a,m)=d=1, то при помоши расширенного алгоритма эвклида представляем НОД в виде
ax+my=d, где d = 1 (см. строкой выше)
Т.е. будет равенство
ax+my=1 mod m
Не трудно видеть, что my-делится на m, т.е. my=0 mod m
Тогда:
ax=1 mod m, т.е. найденное число x будет обратным элементом.

Теперь Расширенный алгоритм эвклида:
1. Прямой ход (Собственно обычный алгоритм эвклида). Приведу короткий пример, будем считать, что алгоритм закончит работу за 3 шага (справа пример на числах a=5, m=7).
Bash
Выделить код

1
2
3
4
5

	

                                    т.к. a<m меняем их местами
a=m*q1+r1                  7 = 5 * 1 + 2     
m=r1*q2+r2                 5 = 2 * 2 + 1
r1=r2*q3                      2 = 1 * 2
r2 - НОД                       1 - НОД

2. Обратный ход
Начинаем выражать остатки с конца (со второго снизу кравнения) и подставлять в уравнения выше
Bash
Выделить код

1
2
3
4

	

r2 = m - r1*q2                             1= 5 - 2*2
r1 = a - m*q1                               2 = 7 -  5* 1
=> r2 = m-(a-m*q1)*q2=            => 1 = 5 - (7-5*1)*2=
= a*(-q2)+m*(1+q1*q2)             =-7 * 1 + 5 * (1+1*2) = -7 +5 * 3

-q2 = a^-1 (обратный) 3 - обратный элемент к 5 по модулю 7: 3*5 = 14 + 1 mod 7 = 1 mod 7
```
