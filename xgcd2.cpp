/*Реализацию тяжко. А вот пояснить, что делать могу.
b - обратный к a по mod m, если a*b = 1 mod m
(a,m) - НОД чисел

При помощи алгоритма Эвклида можно найти НОД этих чисел.

Если (a,m)=d>1 (числа не взаимно простые), то a не имеет обратной величины по модулю m.

Если (a,m)=d=1, то при помоши расширенного алгоритма эвклида представляем НОД в виде
ax+my=d, где d = 1 (см. строкой выше)
Т.е. будет равенство
ax+my=1 mod m
Не трудно видеть, что my-делится на m, т.е. my=0 mod m
Тогда:
ax=1 mod m, т.е. найденное число x будет обратным элементом.

Теперь Расширенный алгоритм эвклида:
1. Прямой ход (Собственно обычный алгоритм эвклида). Приведу короткий пример, будем считать, что алгоритм закончит работу за 3 шага (справа пример на числах a=5, m=7).
Bash
Выделить код

1
2
3
4
5

	

                                    т.к. a<m меняем их местами
a=m*q1+r1                  7 = 5 * 1 + 2     
m=r1*q2+r2                 5 = 2 * 2 + 1
r1=r2*q3                      2 = 1 * 2
r2 - НОД                       1 - НОД

2. Обратный ход
Начинаем выражать остатки с конца (со второго снизу кравнения) и подставлять в уравнения выше
Bash
Выделить код

1
2
3
4

	

r2 = m - r1*q2                             1= 5 - 2*2
r1 = a - m*q1                               2 = 7 -  5* 1
=> r2 = m-(a-m*q1)*q2=            => 1 = 5 - (7-5*1)*2=
= a*(-q2)+m*(1+q1*q2)             =-7 * 1 + 5 * (1+1*2) = -7 +5 * 3

-q2 = a^-1 (обратный) 3 - обратный элемент к 5 по модулю 7: 3*5 = 14 + 1 mod 7 = 1 mod 7


*/



#include <stdio.h>
void extended_euclid(long a, long b, long *x, long *y, long *d)
{
  long q, r, x1, x2, y1, y2;
  if (b == 0) {
    *d = a, *x = 1, *y = 0;
    return;
  }
  x2 = 1, x1 = 0, y2 = 0, y1 = 1;
  while (b > 0) {
    q = a / b, r = a - q * b;
    *x = x2 - q * x1, *y = y2 - q * y1;
    a = b, b = r;
    x2 = x1, x1 = *x, y2 = y1, y1 = *y;
  }
  *d = a, *x = x2, *y = y2;
}

long inverse(long a, long n)
{
  long d, x, y;
  extended_euclid(a, n, &x, &y, &d);
  if (d == 1) return x;
  return 0;
}

int main(void)
{
  long a = 5, n = 7;
  printf("Обратная от %ld по модулю %2ld равняется %ld\n", a, n, inverse(a, n));
  a = 2, n = 12;
  printf("Обратная от %ld по модулю %2ld равняется %ld\n", a, n, inverse(a, n));
  return 0;
}

/*
-------------------------------------------------------------------------------------------
*/

int gcd(int a, int b) {
   int t;
   while (b) {
     t = a % b;
     a = b;
     b = t;        
   }
   return abs(a);
}
 
int ext_gcd(int a, int b, int& x, int& y)
{
   int q, r, x1, x2, y1, y2,d;
   if (b == 0) {
      d = a, x = 1, y = 0;
      return d;
   }
   x2 = 1, x1 = 0, y2 = 0, y1 = 1;
   while (b > 0) {
      q = a / b, r = a - q * b; 
      x = x2 - q * x1, y = y2 - q * y1; 
      a = b, b = r; 
      x2 = x1, x1 = x, y2 = y1, y1 = y;
   }
   d = a, x = x2, y = y2;
   return abs(d);
  
}

/*
-------------------------------------------------------------------------------------------
*/

struct arr3
{
    int a1, a2, a3;
};
 
arr3 MCD(int a, int b)
{
    arr3 U = {a, 1, 0}, V = {b, 0, 1};
    while (V.a1 != 0)
    {
        int q = U.a1 / V.a1;
        arr3 T = {U.a1 % V.a1, U.a2 - q * V.a2, U.a3 - q * V.a3};
        U = V;
        V = T;
    }
    return U;
}
 
int main()
{
    arr3 a;
    a = MCD(10, 5);
    cout << a.a1 << endl;
}
