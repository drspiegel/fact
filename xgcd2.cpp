/*Реализацию тяжко. А вот пояснить, что делать могу.
b - обратный к a по mod m, если a*b = 1 mod m
(a,m) - НОД чисел

При помощи алгоритма Эвклида можно найти НОД этих чисел.

Если (a,m)=d>1 (числа не взаимно простые), то a не имеет обратной величины по модулю m.

Если (a,m)=d=1, то при помоши расширенного алгоритма эвклида представляем НОД в виде
ax+my=d, где d = 1 (см. строкой выше)
Т.е. будет равенство
ax+my=1 mod m
Не трудно видеть, что my-делится на m, т.е. my=0 mod m
Тогда:
ax=1 mod m, т.е. найденное число x будет обратным элементом.

Теперь Расширенный алгоритм эвклида:
1. Прямой ход (Собственно обычный алгоритм эвклида). Приведу короткий пример, будем считать, что алгоритм закончит работу за 3 шага (справа пример на числах a=5, m=7).
Bash
Выделить код

1
2
3
4
5

	

                                    т.к. a<m меняем их местами
a=m*q1+r1                  7 = 5 * 1 + 2     
m=r1*q2+r2                 5 = 2 * 2 + 1
r1=r2*q3                      2 = 1 * 2
r2 - НОД                       1 - НОД

2. Обратный ход
Начинаем выражать остатки с конца (со второго снизу кравнения) и подставлять в уравнения выше
Bash
Выделить код

1
2
3
4

	

r2 = m - r1*q2                             1= 5 - 2*2
r1 = a - m*q1                               2 = 7 -  5* 1
=> r2 = m-(a-m*q1)*q2=            => 1 = 5 - (7-5*1)*2=
= a*(-q2)+m*(1+q1*q2)             =-7 * 1 + 5 * (1+1*2) = -7 +5 * 3

-q2 = a^-1 (обратный) 3 - обратный элемент к 5 по модулю 7: 3*5 = 14 + 1 mod 7 = 1 mod 7


*/

/*
-------------------------------------------------------------------------------------------
*/

int gcd(int a, int b) {
   int t;
   while (b) {
     t = a % b;
     a = b;
     b = t;        
   }
   return abs(a);
}
 
int ext_gcd(int a, int b, int& x, int& y)
{
   int q, r, x1, x2, y1, y2,d;
   if (b == 0) {
      d = a, x = 1, y = 0;
      return d;
   }
   x2 = 1, x1 = 0, y2 = 0, y1 = 1;
   while (b > 0) {
      q = a / b, r = a - q * b; 
      x = x2 - q * x1, y = y2 - q * y1; 
      a = b, b = r; 
      x2 = x1, x1 = x, y2 = y1, y1 = y;
   }
   d = a, x = x2, y = y2;
   return abs(d);
  
}

/*
-------------------------------------------------------------------------------------------
*/

struct arr3
{
    int a1, a2, a3;
};
 
arr3 MCD(int a, int b)
{
    arr3 U = {a, 1, 0}, V = {b, 0, 1};
    while (V.a1 != 0)
    {
        int q = U.a1 / V.a1;
        arr3 T = {U.a1 % V.a1, U.a2 - q * V.a2, U.a3 - q * V.a3};
        U = V;
        V = T;
    }
    return U;
}
 
int main()
{
    arr3 a;
    a = MCD(10, 5);
    cout << a.a1 << endl;
}

// =================================================================


int gcdex(int a, int b, int &x, int &y) {
  if (b == 0) {
    x = 1;
    y = 0;
    return a;
  }
  int x1, y1;
  int d1 = gcdex(b, a % b, x1, y1);
  x = y1;
  y = x1 - (a / b) * y1;
  return d1;
}

// Function returns 1 if such element doesn't exist and 0 if exists and puts it
// in result.
int ReverseElement(int a, int N, int &result) {
  int x, y, d;
  d = gcdex(a, N, x, y);
  if (d != 1) {
    return 1;
  } else {
    result = x;
    return 0;
  }
}

// =================================================================

function dioph2( a,b:int64; var x0,y0:int64 ):int64;
var x1,y1,q,r,x,y:int64;
begin
  x0 := 1; y0 := 0;
  x1 := 0; y1 := 1;
  while b <> 0 do begin
    q := a div b; { Частное }
    r := a mod b; { Остаток }
    a := b;
    b := r;
    x := x0 - x1 * q; y := y0 - y1 * q;
    x0 := x1; y0 := y1;
    x1 := x; y1 := y;
  end;
  dioph2 := a; { НОД(a,b) }
end;
